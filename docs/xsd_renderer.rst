.. _xsd_renderer:

XSD Renderer
------------

Papyrus provides an XSD renderer, capable of serializing SQLAlchemy mapped
classes (including GeoAlchemy geometry columns) into XML Schema Documents.

XSDs generated by the XSD Renderer can, for example, be parsed using
OpenLayers's `DescribeFeatureType format
<http://dev.openlayers.org/apidocs/files/OpenLayers/Format/WFSDescribeFeatureType-js.html>`_.

To use the XSD renderer the XSD renderer factory should be added to the
application configuration.

This is done by either passing the factory to the ``Configurator``
constructor::

    from pyramid.mako_templating import renderer_factory as mako_renderer_factory
    from papyrus.renderers import XSD
    config = Configurator(
        renderers=(('.mako', mako_renderer_factory),
                   ('xsd', XSD()))
        )

Or by applying the ``add_renderer`` method to the ``Configurator`` instance::

    from papyrus.renderers import XSD
    config.add_renderer('xsd', XSD())

Make sure that ``add_renderer`` is called before any ``add_view`` call that
names ``xsd`` as an argument.

To use the XSD renderer in a view set ``renderer`` to ``xsd`` in the
view config. Here is a simple example::

    from sqlalchemy import Column, types
    from sqlalchemy.ext.declarative import declarative_base

    Base = declarative_base()

    @view_config(renderer='xsd')
    def hello_world(request):
        class C(Base):
            __tablename__ = 'table'
            id = Column(types.Integer, primary_key=True)
        return C

Views configured with the ``xsd`` renderer should return SQLAlchemy
mapped classes.

Here's another example::

    @view_config(renderer='xsd')
    def spots_md(request):
        return Spot

Where ``Spot`` is an SQLAlchemy mapped class created using SQLAlchemy's
declarative layer.

Notes:

* By default the XSD renderer skips columns which are primary keys. If you
  wish to include primary keys then pass ``include_primary_keys=True``
  when creating the ``XSD`` objects, for example::

      from papyrus.renderers import XSD
      config.add_renderer('xsd', XSD(include_primary_keys=True))

* By default the XSD renderer skips columns which are foreign keys. Use
  ``include_foreign_keys=True`` to change that behavior. For example::

      from papyrus.renderers import XSD
      config.add_renderer('xsd', XSD(include_foreign_keys=True))

* The XSD renderer adds ``xsd:element`` nodes for the column properties it
  finds in the class. The XSD renderer will ignore other property types. For
  example it will ignore relationship properties and association proxies. If
  you want to add ``xsd:element`` nodes for other elements in the class then
  use a ``sequence_callback``. For example::

      from papyrus.renderers import XSD
      def callback(tb, cls):
          attrs = {}
          attrs['minOccurs'] = str(0)
          attrs['nillable'] = 'true'
          attrs['name'] = 'gender'
          with tag(tb, 'xsd:element', attrs) as tb:
              with tag(tb, 'xsd:simpleType') as tb:
                  with tag(tb, 'xsd:restriction', {'base': 'xsd:string'}) as tb:
                      with tag(tb, 'xsd:enumeration', {'value': 'male'}):
                              pass
                      with tag(tb, 'xsd:enumeration', {'value': 'female'}):
                              pass
      config.add_renderer('xsd', XSD(sequence_callback=callback))

* It is also possible to extend the column property ``xsd::element`` nodes
  using ``element_callback``, for example to add an annotation/appinfo element::

     from papyrus.renderers import XSD
     from papyrus.xsd import tag

     def callback(tb, cls):
         if column.info.get('readonly'):
             with tag(tb, 'xsd:annotation'):
                 with tag(tb, 'xsd:appinfo'):
                     with tag(tb, 'readonly', {'value': 'true'}):
                         pass
     config.add_renderer('xsd', XSD(element_callback=callback))

API Reference
~~~~~~~~~~~~~

.. autoclass:: papyrus.renderers.XSD
